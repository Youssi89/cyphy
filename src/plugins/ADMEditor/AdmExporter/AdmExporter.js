/**
* Generated by PluginGenerator from webgme on Tue Apr 29 2014 17:05:39 GMT-0500 (Central Daylight Time).
*/

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'plugin/AdmExporter/AdmExporter/meta',
    'xmljsonconverter',
    'plugin/AdmExporter/AdmExporter/Templates/Templates',
    'ejs'], function (PluginConfig, PluginBase, MetaTypes, Converter, TEMPLATES, ejs) {
    'use strict';

    /**
    * Initializes a new instance of AdmExporter.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin AdmExporter.
    * @constructor
    */
    var AdmExporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.meta = null;
        this.admData = {
            "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
            "@xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
            "@DesignID": '',
            "@Name": '',
            "@xmlns": "avm",
            "RootContainer": null
        };

        this.acmFiles = {};
        this.gatheredAcms = {};
        this.includeAcms = true;
        // No value flows or connector-compositions beyond the root-container
        // should be reported in the adm file.
        this.rootPath = null;
        this.selectedCfg = null;
        this.selectedAlternatives = null;
    };

    // Prototypal inheritance from PluginBase.
    AdmExporter.prototype = Object.create(PluginBase.prototype);
    AdmExporter.prototype.constructor = AdmExporter;

    /**
    * Gets the name of the AdmExporter.
    * @returns {string} The name of the plugin.
    * @public
    */
    AdmExporter.prototype.getName = function () {
        return "ADM Exporter";
    };

    /**
    * Gets the semantic version (semver.org) of the AdmExporter.
    * @returns {string} The version of the plugin.
    * @public
    */
    AdmExporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the description of the AdmExporter.
    * @returns {string} The description of the plugin.
    * @public
    */
    AdmExporter.prototype.getDescription = function () {
        return "Exports a design into an adm.";
    };

    /**
    * Gets the configuration structure for the AdmExporter.
    * The ConfigurationStructure defines the configuration for the plugin
    * and will be used to populate the GUI when invoking the plugin from webGME.
    * @returns {object} The version of the plugin.
    * @public
    */
    AdmExporter.prototype.getConfigStructure = function () {
        return [
            {
                'name': 'acms',
                'displayName': 'Include ACMs',
                'description': 'Bundles all encountered ACMs within the package and creates scripts for importing the '
                    + 'design into desktop GME.',
                'value': false,
                'valueType': 'boolean',
                'readOnly': false
            },
            {
                'name': 'desertCfg',
                'displayName': 'Desert Configuration.',
                'description': 'Only this configuration will be exported. (If empty whole design space will be exported.)',
                'value': '',
                'valueType': 'string',
                'readOnly': false
            }
        ];
    };


    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    AdmExporter.prototype.main = function (callback) {
        var self = this,
            timeStart = new Date().getTime(),
            jsonToXml = new Converter.Json2xml(),
            config = self.getCurrentConfig(),
            finishAndSaveArtifact,
            createArtifacts;
        if (!self.activeNode) {
            self.createMessage(null, 'Active node is not present! This happens sometimes... Loading another model ' +
                'and trying again will solve it most of times.', 'error');
            callback('Active node is not present!', self.result);
            return;
        }
        if (self.isMetaTypeOf(self.activeNode, self.META.Container) === false) {
            self.createMessage(null, 'This plugin must be called from a Container.', 'error');
            callback(null, self.result);
            return;
        }
        self.meta = MetaTypes;
        self.updateMETA(self.meta);
        self.rootPath = self.core.getPath(self.activeNode);
        finishAndSaveArtifact = function (artifact) {
            artifact.save(function (err, hash) {
                if (err) {
                    self.result.setSuccess(false);
                    callback('Could not save artifact : err' + err.toString(), self.result);
                    return;
                }
                self.result.addArtifact(hash);
                self.result.setSuccess(true);
                callback(null, self.result);
            });
        };

        self.setupDesertCfg(config.desertCfg, function (err) {
            if (err) {
                self.logger.error(err);
                callback(null, self.result);
                return;
            }
            if (self.selectedAlternatives) {
                self.logger.info('Running on single configuration');
                self.logger.info(JSON.stringify(self.selectedAlternatives, null));
            }
            createArtifacts = function (err) {
                var artifact,
                    admXmlStr;
                if (err) {
                    callback(err, self.result);
                    return;
                }
                artifact = self.blobClient.createArtifact('design');
                admXmlStr = jsonToXml.convertToString({Design: self.admData});

                artifact.addFile(self.admData['@Name'] + '.adm', admXmlStr, function (err, hash) {
                    if (err) {
                        self.result.setSuccess(false);
                        callback('Could not add adm file : err' + err.toString(), self.result);
                        return;
                    }
                    self.logger.info('ADM hash: ' + hash);
                    if (self.includeAcms) {
                        artifact.addObjectHashes(self.acmFiles, function (err, hashes) {
                            if (err) {
                                self.result.setSuccess(false);
                                callback('Could not add acm files : err' + err.toString(), self.result);
                                return;
                            }
                            self.logger.info('ACM hashes: ' + hashes.toString());
                            artifact.addFiles({
                                'execute.py': ejs.render(TEMPLATES['execute.py.ejs']),
                                'run_execution.cmd': ejs.render(TEMPLATES['run_execution.cmd.ejs']),
                                'empty.xme': ejs.render(TEMPLATES['empty.xme.ejs']),
                                'executor_config.json': JSON.stringify({
                                    cmd: 'run_execution.cmd',
                                    files: [],
                                    dirs: []
                                }, null, 4)
                            }, function (err, hashes) {
                                if (err) {
                                    callback('Could not script files : err' + err.toString(), self.result);
                                    return;
                                }
                                self.logger.info('Script hashes: ' + hashes.toString());
                                finishAndSaveArtifact(artifact);
                            });
                        });
                    } else {
                        finishAndSaveArtifact(artifact);
                    }
                });
            };
            self.exploreDesign(self.activeNode, config.acms, createArtifacts);
        });
    };

    AdmExporter.prototype.setupDesertCfg = function (desertCfgId, callback) {
        var self = this;
        if (!desertCfgId) {
            callback(null);
            return;
        }
        self.core.loadByPath(self.rootNode, desertCfgId, function (err, cfgNode) {
            var name,
                i,
                aas;
            if (err) {
                self.createMessage(null, 'Could not load given configuration node, err: ' + err.toString(), 'error');
                callback(err);
                return;
            }
            if (self.startsWith(desertCfgId, self.rootPath) === false) {
                self.createMessage(cfgNode, 'Given desert configuration is not within design.', 'error');
                callback('Given desert configuration is not within design.');
                return;
            }
            if (self.isMetaTypeOf(cfgNode, self.meta.DesertConfiguration) === false) {
                self.createMessage(cfgNode, 'Given path to desert configuration is not pointing to a DesertConfiguration node.', 'error');
                callback('Wrong meta-type of desert configuration.');
                return;
            }
            name = self.core.getAttribute(cfgNode, 'name');
            aas = JSON.parse(self.core.getAttribute(cfgNode, 'AlternativeAssignments'));
            self.selectedAlternatives = {};
            for (i = 0; i < aas.length; i += 1) {
                self.selectedAlternatives[aas[i].alternativeOf] = aas[i].selectedAlternative;
            }
            callback(null);
        });
    };

    AdmExporter.prototype.shouldBeGenerated = function (node) {
        var self = this,
            parentNode,
            parentId;
        if (!self.selectedAlternatives) {
            return true;
        }
        parentNode = self.core.getParent(node);
        if (self.core.getAttribute(parentNode, 'Type') !== 'Alternative') {
            return true;
        }
        parentId = self.core.getPath(parentNode);
        if (self.selectedAlternatives[parentId]) {
            if (self.selectedAlternatives[parentId] === self.core.getPath(node)) {
                return true;
            }
        } else {
            self.createMessage(parentNode, 'Container is not in the desert-configuration, the latter is out of date.',
                'error');
            return false;
        }

        return false;
    };

    AdmExporter.prototype.exploreDesign = function (startNode, includeACMs, callback) {
        var self = this,
            designName = self.core.getAttribute(startNode, 'name');
        self.includeAcms = includeACMs;
        self.admData['@Name'] = designName;
        self.admData['@DesignID'] = self.core.getGuid(startNode);
        self.rootPath = self.core.getPath(startNode);
        self.logger.info('rootPath is ' + self.rootPath);
        self.visitAllChildrenFromRootContainer(startNode, callback);
    };

    AdmExporter.prototype.atModelNode = function (node, parent, containerData, callback) {
        var self = this,
            nodeType = self.core.getAttribute(self.getMetaType(node), 'name'),
            nodeName = self.core.getAttribute(node, 'name'),
            parentName = self.core.getAttribute(parent, 'name');

        if (nodeType === 'AVMComponentModel') {
            if (self.shouldBeGenerated(node)) {
                self.addComponentInstance(node, parent, containerData, callback);
            } else {
                self.logger.info('At node "' + nodeName + '" of type "' + nodeType + '" with parent "' + parentName + '".');
                self.logger.info('Will not be generated!');
                callback(null);
            }
        } else if (nodeType === 'Connector') {
            self.addConnector(node, parent, containerData, callback);
        } else if (nodeType === 'Property') {
            self.addProperty(node, parent, containerData, callback);
        } else if (nodeType === 'SimpleFormula') {
            self.addFormula(node, parent, containerData, true, callback);
        } else if (nodeType === 'CustomFormula') {
            self.addFormula(node, parent, containerData, false, callback);
        } else {
            callback(null);
        }
    };

    AdmExporter.prototype.addComponentInstance = function (node, parent, containerData, callback) {
        var self = this,
            pos = self.core.getRegistry(node, 'position'),
            nodeName = self.core.getAttribute(node, 'name'),
            acmHash,
            componentID = self.core.getAttribute(node, 'ID'),
            data = {
                "@Name": nodeName,
                "@ComponentID": componentID,
                "@ID": self.core.getGuid(node),
                "@XPosition": Math.floor(pos.x),
                "@YPosition": Math.floor(pos.y),
                "PortInstance": [],
                "PrimitivePropertyInstance": [],
                "ConnectorInstance": []
            };

        if (containerData.TopLevelSystemUnderTest === undefined) {
            containerData.ComponentInstance.push(data);
        } else {
            containerData.TestComponent.push(data);
        }

        if (self.includeAcms) {
            acmHash = self.core.getAttribute(node, 'Resource');
            if (acmHash) {
                if (self.gatheredAcms[acmHash]) {
                    self.logger.info('ACM of "' + nodeName + '" used twice. Not adding again..');
                } else {
                    self.acmFiles['ACMs/' + nodeName + '__' + componentID.replace(/[^\w]/gi, '_') + '.zip'] = acmHash;
                    self.gatheredAcms[acmHash] = true;
                }
            } else {
                self.logger.error('ACM was not specified for ' + nodeName);
                callback('ACM was not specified for ' + nodeName);
                return;
            }
        }
        self.core.loadChildren(node, function (err, children) {
            var i,
                error = '',
                counter,
                counterCallback;
            if (err) {
                callback('loadChildren failed for ' + nodeName + ' :' + err.toString());
                return;
            }

            counterCallback = function (err) {
                error = err ? error + err : error;
                counter -= 1;
                if (counter <= 0) {
                    callback(error);
                }
            };

            if (children.length === 0) {
                counter = 1;
                counterCallback(null);
                return;
            }

            counter = children.length;

            for (i = 0; i < children.length; i += 1) {
                if (self.isMetaTypeOf(children[i], self.meta.Connector)) {
                    self.addConnector(children[i], node, data, counterCallback);
                } else if (self.isMetaTypeOf(children[i], self.meta.Property)) {
                    self.addProperty(children[i], node, data, counterCallback);
                } else {
                    counterCallback(null);
                }
            }
        });
    };

    AdmExporter.prototype.addConnector = function (node, parent, containerData, callback) {
        var self = this,
            pos,
            parentType = self.core.getAttribute(self.getMetaType(parent), 'name'),
            data,
            collectionNames =  self.core.getCollectionNames(node),
            counter = 2,
            error = '',
            counterCallback = function (err) {
                error = err ? error + err : error;
                counter -= 1;
                if (counter === 0) {
                    callback(error);
                }
            };
        if (parentType === 'Container') {
            pos = self.core.getRegistry(node, 'position');
            data = {
                "@Name": self.core.getAttribute(node, 'name'),
                "@ID": self.core.getGuid(node),
                "@ConnectorComposition": '',
                "@ApplyJoinData": '',
                "@Definition": '',
                "@XPosition": Math.floor(pos.x),
                "@YPosition": Math.floor(pos.y),
                "Role": []
            };
            containerData.Connector.push(data);
        } else {
            // This is a connector instance of a component.
            data = {
                "@ID": '{' + self.core.getGuid(parent) + '}-' + self.core.getAttribute(node, 'ID'),
                "@IDinComponentModel": self.core.getAttribute(node, 'ID'),
                "@ConnectorComposition": '',
                "@ApplyJoinData": ''
            };
            containerData.ConnectorInstance.push(data);
        }

        self.addDomainConnectors(node, data, function (err) {
            if (err) {
                callback(err);
                return;
            }
            if (collectionNames.indexOf('src') > -1) {
                self.getConnectorCompositionID(node, 'src', function (err, dstId) {
                    if (err) {
                        counterCallback(err);
                        return;
                    }
                    data['@ConnectorComposition'] = self.appendWhiteSpacedString(data['@ConnectorComposition'], dstId);
                    counterCallback(null);
                });
            } else {
                counterCallback(null);
            }
            if (collectionNames.indexOf('dst') > -1) {
                self.getConnectorCompositionID(node, 'dst', function (err, srcId) {
                    if (err) {
                        counterCallback(err);
                        return;
                    }
                    data['@ConnectorComposition'] = self.appendWhiteSpacedString(data['@ConnectorComposition'], srcId);
                    counterCallback(null);
                });
            } else {
                counterCallback(null);
            }
        });
    };

    AdmExporter.prototype.addDomainConnectors = function (connectorNode, data, callback) {
        var self = this,
            domainConnectors = data.Role,
            nodeName;

        if (domainConnectors === undefined) {
            // This a connector within an ACM..
            callback(null);
            return;
        }

        nodeName = self.core.getAttribute(connectorNode, 'name');
        self.core.loadChildren(connectorNode, function (err, children) {
            var i,
                typeName,
                domainNodeName;
            if (err) {
                callback('loadChildren failed for connector ' + nodeName + ' :' + err.toString());
                return;
            }
            for (i = 0; i < children.length; i += 1) {
                typeName = self.core.getAttribute(children[i], 'Type');
                domainNodeName = self.core.getAttribute(children[i], 'name');
                if (typeName === 'ModelicaConnector') {
                    domainConnectors.push({
                        '@xmlns:q1': 'modelica',
                        '@xsi:type': 'q1:Connector',
                        '@ID': self.core.getGuid(children[i]),
                        '@PortMap': '',
                        '@Name': domainNodeName,
                        '@Notes': '',
                        '@Definition': '',
                        '@Locator': domainNodeName,
                        '@Class': self.core.getAttribute(children[i], 'Class')
                    });
                } else if (typeName === 'CadAxis') {
                    domainConnectors.push({
                        '@xmlns:q1': 'cad',
                        '@xsi:type': 'q1:Axis',
                        '@ID': self.core.getGuid(children[i]),
                        '@PortMap': '',
                        '@Name': domainNodeName,
                        '@Notes': '',
                        '@Definition': '',
                        '@DatumName': ''
                    });
                } else if (typeName === 'CadCoordinateSystem') {
                    domainConnectors.push({
                        '@xmlns:q1': 'cad',
                        '@xsi:type': 'q1:CoordinateSystem',
                        '@ID': self.core.getGuid(children[i]),
                        '@PortMap': '',
                        '@Name': domainNodeName,
                        '@Notes': '',
                        '@Definition': '',
                        '@DatumName': ''
                    });
                } else if (typeName === 'CadPlane') {
                    domainConnectors.push({
                        '@xmlns:q1': 'cad',
                        '@xsi:type': 'q1:Plane',
                        '@ID': self.core.getGuid(children[i]),
                        '@PortMap': '',
                        '@Name': domainNodeName,
                        '@Notes': '',
                        '@Definition': '',
                        '@DatumName': '',
                        '@SurfaceReverseMap': ''
                    });
                } else if (typeName === 'CadPoint') {
                    domainConnectors.push({
                        '@xmlns:q1': 'cad',
                        '@xsi:type': 'q1:Point',
                        '@ID': self.core.getGuid(children[i]),
                        '@PortMap': '',
                        '@Name': domainNodeName,
                        '@Notes': '',
                        '@Definition': '',
                        '@DatumName': ''
                    });
                }
            }

            callback(null);
        });
    };

    AdmExporter.prototype.getConnectorCompositionID = function (connectorNode, collectionName, callback) {
        var self = this,
            pointerName = collectionName === 'src' ? 'dst' : 'src';

        self.core.loadCollection(connectorNode, collectionName, function (err, connections) {
            var counter, i,
                counterCallback,
                error = '',
                connectedIDs = '';
            if (err) {
                callback(err);
                return;
            }
            counterCallback = function (err, connectedID) {
                if (err) {
                    error += err;
                } else {
                    connectedIDs = self.appendWhiteSpacedString(connectedIDs, connectedID);
                }
                counter -= 1;
                if (counter <= 0) {
                    callback(error, connectedIDs);
                }
            };
            counter = connections.length;
            if (connections.length === 0) {
                counterCallback(null, '');
                return;
            }
            for (i = 0; i < connections.length; i += 1) {
                self.getConnectedPortID(connections[i], pointerName, counterCallback);
            }
        });
    };

    AdmExporter.prototype.getConnectedPortID = function (connectionNode, pointerName, callback) {
        var self = this,
            hasPointer = self.core.hasPointer(connectionNode, pointerName);

        if (hasPointer) {
            self.core.loadPointer(connectionNode, pointerName, function (err, connectedPort) {
                var id = '',
                    parent,
                    parentMetaType;
                if (err) {
                    callback(err);
                    return;
                }
                if (self.nodeIsWithinDesign(connectedPort)) {
                    parent = self.core.getParent(connectedPort);
                    parentMetaType = self.core.getAttribute(self.getMetaType(parent), 'name');
                    if (parentMetaType === 'AVMComponentModel') {
                        //If parent of parent is alternative, then only add if parent is in AA.
                        if (self.shouldBeGenerated(parent)) {
                            id = '{' + self.core.getGuid(parent) + '}-' + self.core.getAttribute(connectedPort, 'ID');
                        }
                    } else if (parentMetaType === 'Container') {
                        //If parent of parent is alternative, then only add if parent is in AA.
                        if (self.shouldBeGenerated(parent)) {
                            id = self.core.getGuid(connectedPort);
                        }
                    } else {
                        callback('Unexpected Connector parentMetaType ' + parentMetaType);
                    }
                }
                callback(null, id);
            });
        } else {
            self.createMessage(connectionNode, 'Connection with no src/dst exists in design.', 'error');
            callback('A connectorComposition with only one direction pointer exists in model.');
        }
    };

    AdmExporter.prototype.addProperty = function (node, parent, containerData, callback) {
        var self = this,
            pos = self.core.getRegistry(node, 'position'),
            parentType = self.core.getAttribute(self.getMetaType(parent), 'name'),
            collectionNames = self.core.getCollectionNames(node),
            valueType = self.core.getAttribute(node, 'ValueType'),
            dataType = self.core.getAttribute(node, 'DataType'),
            unit,
            data,
            value,
            id,
            addPropertyData;

        addPropertyData = function (valueSourceID) {
            if (parentType === 'Container') {
                id = self.core.getGuid(node);
                data = {
                    "@xsi:type": "q1:PrimitiveProperty",
                    "@Name": self.core.getAttribute(node, 'name'),
                    "@ID": null,
                    "@XPosition": Math.floor(pos.x),
                    "@YPosition": Math.floor(pos.y),
                    "Value": {
                        "@ID": id,
                        "@DimensionType": "Scalar",
                        "@Dimensions": "",
                        "@DataType": dataType,
                        "ValueExpression": null
                    }
                };
                unit = self.core.getAttribute(node, 'Unit');
                if (unit) {
                    data.Value['@Unit'] = unit;
                }
                value = self.core.getAttribute(node, 'Value') || '';
                if (valueType === 'Parametric') {
                    data['@ID'] = 'param.' + id;
                    data.Value.ValueExpression = {
                        "@xsi:type": "q1:" + valueType + "Value",
                        "Default": {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": self.core.getAttribute(node, 'Default') || ''
                            }
                        },
                        "Maximum": {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": self.core.getAttribute(node, 'Maximum') || ''
                            }
                        },
                        "Minimum": {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": self.core.getAttribute(node, 'Minimum') || ''
                            }
                        },
                        "AssignedValue": null
                    };
                    if (valueSourceID) {
                        data.Value.ValueExpression.AssignedValue = {
                            "@xsi:type": "q1:DerivedValue",
                            "@ValueSource": valueSourceID
                        };
                    } else {
                        data.Value.ValueExpression.AssignedValue = {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": value
                            }
                        };
                    }
                } else {
                    data['@ID'] = 'property.' + id;
                    if (valueSourceID) {
                        data.Value.ValueExpression = {
                            "@xsi:type": "q1:DerivedValue",
                            "@ValueSource": valueSourceID
                        };
                    } else {
                        data.Value.ValueExpression = {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": value
                            }
                        };
                    }
                }
                containerData.Property.push(data);
            } else {
                id = self.core.getAttribute(node, 'ID');
                data = {
                    "@IDinComponentModel": id,
                    "Value": {
                        "@ID": '{' + self.core.getGuid(parent) + '}-' + id,
                        "@DimensionType": "Scalar",
                        "@Dimensions": "",
                        "@DataType": dataType
                    }
                };
                if (valueSourceID) {
                    data.Value.ValueExpression = {
                        "@xsi:type": "q1:DerivedValue",
                        "@ValueSource": valueSourceID
                    };
                }
                containerData.PrimitivePropertyInstance.push(data);
            }

            callback(null);
        };
        if (collectionNames.indexOf('dst') < 0) {
            addPropertyData(null);
        } else {
            self.core.loadCollection(node, 'dst', function (err, valueFlows) {
                if (err) {
                    callback('Could not load collection for ' + self.core.getAttribute(node, 'name') +
                        'err: ' + err.toString());
                    return;
                }
                if (valueFlows.length > 1) {
                    if (self.core.getAttribute(parent, 'Type') !== 'Alternative') {
                        // With only one configuration or within a non-alternative container there should not be any muxes!
                        self.createMessage(node, self.core.getAttribute(node, 'name') + ' had more than one incoming value', 'warning');
                        callback(null);
                    } else if (self.selectedAlternatives) {
                        self.getValueSrcId(valueFlows, node, parent, function (err, srcId) {
                            if (err) {
                                callback('Problems getting ValueSrcId in alternative for configuration, err: ' + err);
                            } else {
                                addPropertyData(srcId);
                            }
                        });
                    } else {
                        self.addValueFlowMux(valueFlows, parent, containerData, function (err, muxId) {
                            if (err) {
                                self.createMessage(node, 'Property had multiple incoming value-flows.' +
                                    ' Failed to add valueFlow-mux for it.', 'error');
                                callback(err);
                            } else {
                                addPropertyData(muxId);
                            }
                        });
                    }
                } else {
                    self.getValueSrcId(valueFlows, node, parent, function (err, srcId) {
                        if (err) {
                            callback('Problems getting ValueSrcId, err: ' + err);
                        } else {
                            addPropertyData(srcId);
                        }
                    });
                }
            });
        }
    };

    AdmExporter.prototype.addFormula = function (node, parent, containerData, isSimple, callback) {
        var self = this,
            pos = self.core.getRegistry(node, 'position'),
            collectionNames = self.core.getCollectionNames(node),
            formulaName = self.core.getAttribute(node, 'name'),
            data,
            id = self.core.getGuid(node),
            addFormulaData;
        self.logger.info('At formula "' + formulaName + '".');
        addFormulaData = function (operands, error) {
            var i;
            if (isSimple) {
                data = {
                    "@xmlns:q1": "avm",
                    "@xmlns": "",
                    "@xsi:type": "q1:SimpleFormula",
                    "@ID": id,
                    "@Name": formulaName,
                    "@XPosition": Math.floor(pos.x),
                    "@YPosition": Math.floor(pos.y),
                    "@Operation": self.core.getAttribute(node, 'Method'),
                    "@Operand": ''
                };
                for (i = 0; i < operands.length; i += 1) {
                    data["@Operand"] = self.appendWhiteSpacedString(data["@Operand"], operands[i].id);
                }
            } else {
                data = {
                    "@xmlns:q1": "avm",
                    "@xmlns": "",
                    "@xsi:type": "q1:ComplexFormula",
                    "@ID": id,
                    "@Name": formulaName,
                    "@XPosition": Math.floor(pos.x),
                    "@YPosition": Math.floor(pos.y),
                    "@Expression": self.core.getAttribute(node, 'Expression'),
                    "Operand": []
                };
                for (i = 0; i < operands.length; i += 1) {
                    data.Operand.push({
                        "@Symbol": operands[i].symbol,
                        "@ValueSource": operands[i].id
                    });
                }
            }
            containerData.Formula.push(data);
            callback(error);
        };

        if (collectionNames.indexOf('dst') < 0) {
            addFormulaData(null);
        } else {
            self.core.loadCollection(node, 'dst', function (err, valueFlows) {
                var counter = valueFlows.length,
                    i,
                    error = '',
                    operands = [],
                    counterCallback;
                if (err) {
                    callback('Could not load collection for ' + formulaName + 'err: ' + err.toString());
                    return;
                }
                counter = valueFlows.length;
                counterCallback = function (valueFlow) {

                    return function (err, valueSource) {
                        var symbol,
                            valueSourceId,
                            valueSourceParent,
                            parentMetaType;

                        if (err) {
                            error += err;
                        } else {
                            valueSourceParent = self.core.getParent(valueSource);
                            parentMetaType = self.core.getAttribute(self.getMetaType(valueSourceParent), 'name');
                            if (parentMetaType === 'AVMComponentModel') {
                                if (self.shouldBeGenerated(valueSourceParent)) {
                                    valueSourceId = '{' + self.core.getGuid(valueSourceParent) + '}-' + self.core.getAttribute(valueSource, 'ID');
                                }
                            } else if (parentMetaType === 'Container') {
                                //If parent of parent is alternative, then only add if parent is in AA.
                                if (self.shouldBeGenerated(valueSourceParent)) {
                                    valueSourceId = self.core.getGuid(valueSource);
                                }
                            } else {
                                self.logger.error('Unexpected parentMetaType of valueSourceNode' + parentMetaType);
                            }

                            if (!isSimple) {
                                symbol = self.core.getAttribute(valueFlow, 'VariableName');
                                if (!symbol) {
                                    symbol = self.core.getAttribute(valueSource, 'name');
                                }
                            }
                            if (valueSourceId) {
                                operands.push({
                                    symbol: symbol,
                                    id: valueSourceId
                                });
                            }
                        }
                        counter -= 1;
                        if (counter <= 0) {
                            addFormulaData(operands, error);
                        }
                    };
                };
                if (counter === 0) {
                    self.logger.warning('Formula "' + formulaName + '" did not have any incoming value flows.');
                    addFormulaData([], error);
                }
                for (i = 0; i < valueFlows.length; i += 1) {
                    if (self.core.hasPointer(valueFlows[i], 'src')) {
                        self.core.loadPointer(valueFlows[i], 'src', counterCallback(valueFlows[i]));
                    } else {
                        self.createMessage(valueFlows[i], 'ValueFlow Connection with no src exists in design.', 'error');
                        counterCallback(valueFlows[i])('A valueFlow with only one direction pointer exists in model.');
                    }
                }
            });
        }
    };

    AdmExporter.prototype.addValueFlowMux = function (valueFlows, parent, containerData, callback) {
        var self = this,
            i,
            counter = valueFlows.length,
            s4 = function () {
                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
            },
            mux = {
                '@ID': 'muxid-' + s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4(),
                '@Source': ''
            },
            error = '',
            counterCallback = function (err, valueSource) {
                var valueSourceId,
                    valueSourceParent,
                    parentMetaType;

                if (err) {
                    error += err;
                } else {
                    valueSourceParent = self.core.getParent(valueSource);
                    parentMetaType = self.core.getAttribute(self.getMetaType(valueSourceParent), 'name');
                    if (parentMetaType === 'AVMComponentModel') {
                        valueSourceId = '{' + self.core.getGuid(valueSourceParent) + '}-' + self.core.getAttribute(valueSource, 'ID');
                    } else if (parentMetaType === 'Container') {
                        valueSourceId = self.core.getGuid(valueSource);
                    } else {
                        self.logger.error('Unexpected parentMetaType of valueSourceNode' + parentMetaType);
                    }
                    mux['@Source'] = self.appendWhiteSpacedString(mux['@Source'], valueSourceId);
                }
                counter -= 1;
                if (counter <= 0) {
                    callback(error, mux['@ID']);
                }
            };

        containerData.ValueFlowMux.push(mux);
        for (i = 0; i < valueFlows.length; i += 1) {
            if (self.core.hasPointer(valueFlows[i], 'src')) {
                self.core.loadPointer(valueFlows[i], 'src', counterCallback);
            } else {
                self.createMessage(valueFlows[i], 'ValueFlow Connection with no src exists in design.', 'error');
                counterCallback('A valueFlow with only one direction pointer exists in model.');
            }
        }
    };

    AdmExporter.prototype.getValueSrcId = function (valueFlows, targetNode, targetParent, callback) {
        var self = this,
            error = '',
            i,
            finalSrcId,
            counter = valueFlows.length,
            parentType = self.getMetaType(targetParent),
            atValueFlowNode = function (valueFlow) {
                var srcId;
                counter -= 1;
                if (!self.core.hasPointer(valueFlow, 'src')) {
                    self.createMessage(valueFlow, 'ValueFlow Connection with no src exists in design.', 'error');
                    error += 'A valueFlow with only one direction pointer exists in model.';
                    if (counter <= 0) {
                        callback(error, null);
                    }
                } else {
                    self.core.loadPointer(valueFlow, 'src', function (err, valueSourceNode) {
                        var src,
                            srcParentMetaType;
                        if (err) {
                            error += 'Could not load src pointer for ' + self.core.getAttribute(valueFlow, 'name')
                                + 'err: ' + err.toString();
                        } else if (self.nodeIsWithinDesign(valueSourceNode)) {
                            src = self.core.getParent(valueSourceNode);
                            srcParentMetaType = self.core.getAttribute(self.getMetaType(src), 'name');
                            if (srcParentMetaType === 'AVMComponentModel') {
                                if (parentType === 'AVMComponentModel' && self.core.getPath(src) === self.core.getPath(targetParent)) {
                                    self.logger.info('Skipping connection within same ACM : ' +
                                        self.core.getAttribute(targetNode, 'name'));
                                } else {
                                    // If parent of parent is alternative, then only add if parent is in AA.
                                    if (self.shouldBeGenerated(src)) {
                                        srcId = '{' + self.core.getGuid(src) + '}-' + self.core.getAttribute(valueSourceNode, 'ID');
                                    }
                                }
                            } else if (srcParentMetaType === 'Container') {
                                //If parent of parent is alternative, then only add if parent is in AA.
                                if (self.shouldBeGenerated(src)) {
                                    srcId = self.core.getGuid(valueSourceNode);
                                }
                            } else {
                                self.logger.error('Unexpected parentMetaType of valueSourceNode' + srcParentMetaType);
                            }
                        }
                        if (srcId) {
                            if (finalSrcId) {
                                self.createMessage(targetNode, 'Cannot have more than one incoming value.', 'error');
                                error += 'There is more than one incoming value..';
                            } else {
                                finalSrcId = srcId;
                            }
                        }
                        if (counter <= 0) {
                            callback(error, finalSrcId);
                        }
                    });
                }
            };
        for (i = 0; i < valueFlows.length; i += 1) {
            atValueFlowNode(valueFlows[i]);
        }
    };

    AdmExporter.prototype.visitAllChildrenFromRootContainer = function (rootNode, callback) {
        var self = this,
            error = '',
            counter,
            counterCallback,
            containerData;

        counter = {visits: 1};
        counterCallback = function (err) {
            error = err ? error + err : error;
            counter.visits -= 1;
            if (counter.visits === 0) {
                callback(error);
            }
        };

        containerData = self.getContainerData(rootNode, true);
        self.admData.RootContainer = containerData;
        self.visitAllChildrenRec(rootNode, counter, containerData, counterCallback);
    };

    AdmExporter.prototype.visitAllChildrenRec = function (node, counter, containerData, callback) {
        var self = this;
        self.core.loadChildren(node, function (err, children) {
            var i,
                atModelNodeCallback;
            if (err) {
                callback('loadChildren failed for ' + self.core.getAttribute(node, 'name'));
                return;
            }
            if (children.length === 0) {
                callback(null);
            } else {
                counter.visits += children.length;
                counter.visits -= 1;
                atModelNodeCallback = function (childNode) {
                    return function (err) {
                        var subContainerData;
                        if (err) {
                            callback(err);
                            return;
                        }
                        if (self.isMetaTypeOf(childNode, self.meta.Container) && self.shouldBeGenerated(childNode)) {
                            // If containerData is Alternative, then only add if childNode.id is in AA.
                            subContainerData = self.getContainerData(childNode);
                            containerData.Container.push(subContainerData);
                            self.visitAllChildrenRec(childNode, counter, subContainerData, callback);
                        } else {
                            callback(null);
                        }
                    };
                };
                for (i = 0; i < children.length; i += 1) {
                    self.atModelNode(children[i], node, containerData, atModelNodeCallback(children[i]));
                }
            }
        });
    };

    AdmExporter.prototype.getContainerData = function (node, isRoot) {
        var self = this,
            pos,
            containerData = {
                "@xmlns:q1": "avm",
                "@xsi:type": 'q1:' + self.core.getAttribute(node, 'Type'),
                "@Name": self.core.getAttribute(node, 'name'),
                "@xmlns": "",
                "Container": [],
                "Property": [],
                "ComponentInstance": [],
                "Port": [],
                "Connector": [],
                "JoinData": [],
                "Formula": [],
                "ValueFlowMux": []
            };

        if (!isRoot) {
            pos = self.core.getRegistry(node, 'position');
            containerData["@XPosition"] = Math.floor(pos.x);
            containerData["@YPosition"] = Math.floor(pos.y);
        }

        return containerData;
    };

    AdmExporter.prototype.appendWhiteSpacedString = function (toBeAppended, appendix) {
        if (appendix) {
            if (toBeAppended) {
                toBeAppended += " " + appendix;
            } else {
                toBeAppended = appendix;
            }
        }
        return toBeAppended;
    };

    AdmExporter.prototype.nodeIsWithinDesign = function (node) {
        var self = this,
            path = self.core.getPath(node);
        if (self.startsWith(path, self.rootPath)) {
            return true;
        }
        self.logger.info('Connection to node with path ' + path + ' will not be generated.' +
            'It is not part of the root-design');
        return false;
    };

    AdmExporter.prototype.startsWith = function (str, start) {
        if (start === '') {
            return true;
        }
        return start.length > 0 && str.substring(0, start.length) === start;
    };

    return AdmExporter;
});